# Issues-FS CLI: LLM Implementation Guide

**Document:** issues-fs__cli-implementation-guide  
**Version:** v1.0  
**Date:** 2026-02-06  
**Status:** Implementation Ready  
**Companion To:** issues-fs__cli-architecture v1.0  
**Depends On:** issues-fs codebase (dev branch), osbot-utils v3.63+  

---

## Purpose

This document is an implementation guide for building the Issues-FS CLI. It is written for LLM agents who will implement the code. Use this document **alongside** the CLI architecture document (v0_4_0__issues-fs__cli-architecture.md) which defines the user-facing design. This document tells you **how to build it** — which services exist, how to call them, what schemas to use, how to format the code, and what to defer.

---

## Critical Context: The Service Layer Already Exists

The CLI is **not** a greenfield implementation. The Issues-FS codebase (`issues_fs` namespace, `dev` branch) already contains a complete service layer with CRUD operations, graph traversal, link management, comments, and type configuration. The CLI's job is:

1. Parse command-line arguments (using Typer)
2. Construct `Schema__*__Request` objects from those arguments
3. Call the appropriate service method
4. Format the `Schema__*__Response` for the chosen output mode
5. Set the exit code based on `response.success`

**Do not reinvent the service layer.** Do not write raw file operations. Do not build a new graph traversal. Call the existing services.

---

## Existing Services — Complete Reference

### Where the Code Lives

```
issues_fs/issues/graph_services/
    ├── Graph__Repository.py              # Storage abstraction (Memory-FS backed)
    ├── Graph__Repository__Factory.py     # Factory for storage backends
    ├── Node__Service.py                  # Node CRUD + graph traversal
    ├── Link__Service.py                  # Bidirectional link management
    ├── Comments__Service.py              # Comment CRUD on nodes
    ├── Type__Service.py                  # Node type + link type management
    └── __init__.py
```

### Command-to-Service Mapping

Every CLI command maps to an existing service method. This table is the primary reference for implementation:

| CLI Command | Service Class | Method | Request Schema | Response Schema |
|---|---|---|---|---|
| `issues-fs create <type> "<title>"` | `Node__Service` | `create_node(request)` | `Schema__Node__Create__Request` | `Schema__Node__Create__Response` |
| `issues-fs update <label> --field val` | `Node__Service` | `update_node(node_type, label, request)` | `Schema__Node__Update__Request` | `Schema__Node__Update__Response` |
| `issues-fs show <label>` | `Node__Service` | `get_node(node_type, label)` | — (direct args) | `Schema__Node` (or None) |
| `issues-fs show <label> --depth N` | `Node__Service` | `get_node_graph(node_type, label, depth)` | — (direct args) | `Schema__Graph__Response` |
| `issues-fs list` | `Node__Service` | `list_nodes()` | — | `Schema__Node__List__Response` |
| `issues-fs list --type <type>` | `Node__Service` | `list_nodes(node_type)` | — | `Schema__Node__List__Response` |
| `issues-fs delete <label>` | `Node__Service` | `delete_node(node_type, label)` | — (direct args) | `Schema__Node__Delete__Response` |
| `issues-fs link <source> --<verb> <target>` | `Link__Service` | `create_link(source_type, source_label, request)` | `Schema__Link__Create__Request` | `Schema__Link__Create__Response` |
| `issues-fs unlink <source> <target>` | `Link__Service` | `delete_link(source_type, source_label, target_label)` | — (direct args) | `Schema__Link__Delete__Response` |
| `issues-fs comment <label> "<text>"` | `Comments__Service` | `create_comment(node_type, label, request)` | `Schema__Comment__Create__Request` | `Schema__Comment__Response` |
| `issues-fs comments <label>` | `Comments__Service` | `list_comments(node_type, label)` | — (direct args) | `Schema__Comment__List__Response` |
| `issues-fs types list` | `Type__Service` | `list_node_types()` | — | `List[Schema__Node__Type]` |
| `issues-fs types init` | `Type__Service` | `initialize_default_types()` | — | None |
| `issues-fs link-types list` | `Type__Service` | `list_link_types()` | — | `List[Schema__Link__Type]` |

### Label-to-Type Resolution

The existing `Link__Service.parse_label()` method derives `node_type` from a label:

```python
# "Bug-27" → ("bug", "Bug-27")
# "Task-15" → ("task", "Task-15")
label_str = str(label)
parts     = label_str.split('-', 1)
node_type = parts[0].lower()
```

The CLI should use this same pattern to extract `node_type` from the label argument, so users never have to specify type separately when they provide a label like `Task-23`.

### How Services Are Instantiated

Services require a `Graph__Repository` which is created via the factory:

```python
from issues_fs.issues.graph_services.Graph__Repository__Factory import Graph__Repository__Factory
from issues_fs.issues.graph_services.Node__Service              import Node__Service
from issues_fs.issues.graph_services.Link__Service              import Link__Service
from issues_fs.issues.graph_services.Comments__Service          import Comments__Service
from issues_fs.issues.graph_services.Type__Service              import Type__Service

# For local disk (the primary CLI backend — operates on .issues/ in a git repo)
repository = Graph__Repository__Factory.create_local_disk(root_path='/path/to/repo/.issues')

# Create services
node_service     = Node__Service    (repository = repository)
link_service     = Link__Service    (repository = repository)
comments_service = Comments__Service(repository = repository)
type_service     = Type__Service    (repository = repository)
```

The CLI must resolve `root_path` by finding the nearest `.issues/` directory, walking up from `cwd`. This is analogous to how `git` finds `.git/`.

---

## ID Scheme — Already Implemented

Labels follow the pattern `{Type.capitalize()}-{auto_index}`:

- Generated by `Node__Service.label_from_type_and_index()`
- Examples: `Bug-1`, `Task-23`, `Feature-5`, `Person-2`
- Internal `node_id` is an `Obj_Id` (8-char hex), but **the CLI always uses labels as the user-facing identifier**
- `node_index` is per-type auto-increment, tracked in `Schema__Type__Index.next_index`
- Safety loop in `create_node()` skips collisions if `next_index` points to an existing label

The CLI should accept labels as positional arguments and parse them with the same `split('-', 1)` logic used by `Link__Service.parse_label()`.

---

## Architecture: CLI Module Structure

```
issues_fs/
    └── cli/
        ├── __init__.py
        ├── cli__main.py                    # Typer app definition + root commands
        ├── cli__create.py                  # 'create' command group
        ├── cli__update.py                  # 'update' command
        ├── cli__show.py                    # 'show' command
        ├── cli__list.py                    # 'list' command
        ├── cli__delete.py                  # 'delete' command
        ├── cli__link.py                    # 'link' and 'unlink' commands
        ├── cli__comment.py                 # 'comment' and 'comments' commands
        ├── cli__types.py                   # 'types' subcommand group
        ├── cli__config.py                  # Configuration loading
        ├── cli__context.py                 # Shared context (repo discovery, service init)
        ├── cli__output.py                  # Output formatting (table, json, yaml, markdown)
        └── cli__label_parser.py            # Label → (node_type, label) resolution
```

### Entry Point

Register via `pyproject.toml`:

```toml
[project.scripts]
issues-fs = "issues_fs.cli.cli__main:app"
```

---

## Implementation Patterns

### Pattern 1: Basic Command (show)

This is the canonical pattern. Every command follows this shape:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI Show Command - Display a node and its subgraph
# ═══════════════════════════════════════════════════════════════════════════════

import typer
from typing                                                      import Optional
from issues_fs.cli.cli__context                                  import CLI__Context
from issues_fs.cli.cli__output                                   import CLI__Output
from issues_fs.cli.cli__label_parser                             import CLI__Label_Parser

app = typer.Typer()


@app.command("show")
def show(label     : str                                         ,               # Node label (e.g. Task-23)
         depth     : int            = typer.Option(0)            ,               # Traversal depth for graph view
         output    : str            = typer.Option("table")      ,               # Output format
         for_agent : bool           = typer.Option(False)                        # Agent-optimized output
    ) -> None:                                                                   # Display node details
    context    = CLI__Context()
    node_type  = CLI__Label_Parser.parse_type(label)
    node_label = CLI__Label_Parser.parse_label(label)

    if node_type is None:
        CLI__Output.error(f"Invalid label format: {label}")
        raise typer.Exit(code=1)

    if depth > 0:
        response = context.node_service.get_node_graph(node_type = node_type  ,
                                                       label     = node_label ,
                                                       depth     = depth      )
        if response.success is False:
            CLI__Output.error(response.message)
            raise typer.Exit(code=1)

        CLI__Output.render_graph(response                  ,
                                 format    = output        ,
                                 for_agent = for_agent     )
    else:
        node = context.node_service.get_node(node_type = node_type  ,
                                             label     = node_label )
        if node is None:
            CLI__Output.error(f"Node not found: {label}")
            raise typer.Exit(code=1)

        CLI__Output.render_node(node                       ,
                                format    = output         ,
                                for_agent = for_agent      )
```

### Pattern 2: Create Command (with request schema)

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI Create Command - Create new issue nodes
# ═══════════════════════════════════════════════════════════════════════════════

import typer
from typing                                                                     import Optional, List
from issues_fs.cli.cli__context                                                 import CLI__Context
from issues_fs.cli.cli__output                                                  import CLI__Output
from issues_fs.schemas.graph.Schema__Node__Create__Request                      import Schema__Node__Create__Request
from issues_fs.schemas.graph.Safe_Str__Graph_Types                              import Safe_Str__Node_Type

app = typer.Typer()


@app.command("create")
def create(node_type   : str                                     ,               # Type (bug, task, feature)
           title       : str                                     ,               # Issue title
           description : str  = typer.Option("")                 ,               # Description
           status      : str  = typer.Option(None)               ,               # Initial status (uses type default if omitted)
           priority    : str  = typer.Option(None)               ,               # Priority level
           tags        : str  = typer.Option(None)               ,               # Comma-separated tags
           output      : str  = typer.Option("table")            ,               # Output format
           for_agent   : bool = typer.Option(False)                              # Agent-optimized output
      ) -> None:                                                                 # Create a new node
    context    = CLI__Context()

    properties = {}
    if priority:
        properties['priority'] = priority

    tag_list = [t.strip() for t in tags.split(',')] if tags else []

    request = Schema__Node__Create__Request(node_type   = Safe_Str__Node_Type(node_type) ,
                                            title       = title                          ,
                                            description = description                    ,
                                            status      = status or ''                   ,
                                            tags        = tag_list                        ,
                                            properties  = properties                     )

    response = context.node_service.create_node(request)

    if response.success is False:
        CLI__Output.error(response.message)
        raise typer.Exit(code=1)

    CLI__Output.render_create_response(response                ,
                                       format    = output      ,
                                       for_agent = for_agent   )
```

### Pattern 3: Link Command (dynamic verb from link types)

The CLI architecture doc uses `--blocks`, `--depends-on` etc. as flags. To avoid namespace collisions with other CLI flags and to keep the implementation simple, use a `--verb` option:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI Link Command - Create and remove edges between nodes
# ═══════════════════════════════════════════════════════════════════════════════

import typer
from issues_fs.cli.cli__context                                                 import CLI__Context
from issues_fs.cli.cli__output                                                  import CLI__Output
from issues_fs.cli.cli__label_parser                                            import CLI__Label_Parser
from issues_fs.schemas.graph.Schema__Link__Create__Request                      import Schema__Link__Create__Request
from issues_fs.schemas.graph.Safe_Str__Graph_Types                              import Safe_Str__Link_Verb, Safe_Str__Node_Label

app = typer.Typer()


@app.command("link")
def link(source    : str                                         ,               # Source label (e.g. Task-23)
         target    : str                                         ,               # Target label (e.g. Bug-1)
         verb      : str  = typer.Option(...)                    ,               # Link verb (blocks, depends-on, etc.)
         output    : str  = typer.Option("table")                ,               # Output format
         for_agent : bool = typer.Option(False)                                  # Agent-optimized output
    ) -> None:                                                                   # Create link between nodes
    context      = CLI__Context()
    source_type  = CLI__Label_Parser.parse_type(source)
    source_label = CLI__Label_Parser.parse_label(source)

    if source_type is None:
        CLI__Output.error(f"Invalid source label: {source}")
        raise typer.Exit(code=1)

    request = Schema__Link__Create__Request(verb         = Safe_Str__Link_Verb(verb)   ,
                                            target_label = Safe_Str__Node_Label(target) )

    response = context.link_service.create_link(source_type  = source_type  ,
                                                source_label = source_label ,
                                                request      = request      )

    if response.success is False:
        CLI__Output.error(response.message)
        raise typer.Exit(code=1)

    CLI__Output.render_link_response(response                ,
                                     format    = output      ,
                                     for_agent = for_agent   )


@app.command("unlink")
def unlink(source    : str                                       ,               # Source label
           target    : str                                       ,               # Target label
           output    : str  = typer.Option("table")              ,               # Output format
           for_agent : bool = typer.Option(False)                                # Agent-optimized output
      ) -> None:                                                                 # Remove link between nodes
    context      = CLI__Context()
    source_type  = CLI__Label_Parser.parse_type(source)
    source_label = CLI__Label_Parser.parse_label(source)

    if source_type is None:
        CLI__Output.error(f"Invalid source label: {source}")
        raise typer.Exit(code=1)

    response = context.link_service.delete_link(source_type  = source_type                   ,
                                                source_label = source_label                   ,
                                                target_label = Safe_Str__Node_Label(target)   )

    if response.success is False:
        CLI__Output.error(response.message)
        raise typer.Exit(code=1)

    CLI__Output.render_unlink_response(response                ,
                                       format    = output      ,
                                       for_agent = for_agent   )
```

**Note on verb syntax:** The CLI architecture doc proposes `issues-fs link Task-23 --blocks Task-24` (verb as flag name). This is ergonomically nice but creates a flag namespace collision risk (e.g. a custom link type called `output` would collide with `--output`). Two valid approaches:

- **Option A (safe):** `issues-fs link Task-23 Task-24 --verb blocks` — verb is a named option.
- **Option B (ergonomic):** `issues-fs link Task-23 blocks Task-24` — verb is a positional argument between source and target.

Option B is recommended as a compromise: no namespace collision, reads naturally, and the verb set is discoverable via `issues-fs link-types list`. The implementation above uses Option A for clarity; adapt to Option B by making `verb` a positional `typer.Argument`.

---

## CLI Context — Repository Discovery and Service Initialisation

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI__Context - Discovers .issues/ directory and initialises services
# ═══════════════════════════════════════════════════════════════════════════════

import os
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from issues_fs.issues.graph_services.Graph__Repository__Factory                 import Graph__Repository__Factory
from issues_fs.issues.graph_services.Graph__Repository                          import Graph__Repository
from issues_fs.issues.graph_services.Node__Service                              import Node__Service
from issues_fs.issues.graph_services.Link__Service                              import Link__Service
from issues_fs.issues.graph_services.Comments__Service                          import Comments__Service
from issues_fs.issues.graph_services.Type__Service                              import Type__Service


class CLI__Context(Type_Safe):                                                   # CLI runtime context
    repository       : Graph__Repository  = None                                 # Storage layer
    node_service     : Node__Service      = None                                 # Node operations
    link_service     : Link__Service      = None                                 # Link operations
    comments_service : Comments__Service  = None                                 # Comment operations
    type_service     : Type__Service      = None                                 # Type operations

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.repository is None:
            root_path       = self.discover_issues_root()
            self.repository = Graph__Repository__Factory.create_local_disk(root_path = root_path)

        self.node_service     = Node__Service    (repository = self.repository)
        self.link_service     = Link__Service    (repository = self.repository)
        self.comments_service = Comments__Service(repository = self.repository)
        self.type_service     = Type__Service    (repository = self.repository)

    def discover_issues_root(self) -> str:                                       # Walk up from cwd to find .issues/
        current = os.getcwd()

        while True:
            candidate = os.path.join(current, '.issues')
            if os.path.isdir(candidate):
                return candidate

            parent = os.path.dirname(current)
            if parent == current:                                                # Reached filesystem root
                raise FileNotFoundError(
                    "No .issues/ directory found. "
                    "Run 'issues-fs init' to create one, "
                    "or run this command from within an Issues-FS repository."
                )
            current = parent
```

---

## Label Parser — Reuses Existing Logic

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI__Label_Parser - Parse user-provided labels into (type, label) pairs
# Mirrors Link__Service.parse_label() logic
# ═══════════════════════════════════════════════════════════════════════════════

from typing                                                                     import Optional
from issues_fs.schemas.graph.Safe_Str__Graph_Types                              import Safe_Str__Node_Type, Safe_Str__Node_Label


class CLI__Label_Parser:                                                         # Label parsing utilities

    @staticmethod
    def parse_type(label: str) -> Optional[Safe_Str__Node_Type]:                 # Extract type from label
        if '-' not in label:                                                     # "Bug-27" → "bug"
            return None
        parts = label.split('-', 1)
        if len(parts) != 2:
            return None
        try:
            return Safe_Str__Node_Type(parts[0].lower())
        except Exception:
            return None

    @staticmethod
    def parse_label(label: str) -> Optional[Safe_Str__Node_Label]:               # Validate and wrap label
        if '-' not in label:
            return None
        try:
            return Safe_Str__Node_Label(label)
        except Exception:
            return None
```

---

## Output Formatting

The CLI must support multiple output formats. The `--output` flag accepts: `table`, `json`, `yaml`, `markdown`. The `--for-agent` flag forces JSON and includes all fields.

### Output Renderer Design

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI__Output - Render service responses for terminal or agent consumption
# ═══════════════════════════════════════════════════════════════════════════════

import json
import sys
from typing                                                                     import Optional
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from issues_fs.schemas.graph.Schema__Node                                       import Schema__Node
from issues_fs.schemas.graph.Schema__Node__Create__Response                     import Schema__Node__Create__Response
from issues_fs.schemas.graph.Schema__Node__List__Response                       import Schema__Node__List__Response
from issues_fs.schemas.graph.Schema__Graph__Response                            import Schema__Graph__Response


class CLI__Output:                                                               # Output formatting utilities

    @staticmethod
    def error(message: str) -> None:                                             # Print error to stderr
        sys.stderr.write(f"Error: {message}\n")

    @staticmethod
    def success(message: str) -> None:                                           # Print success message
        sys.stdout.write(f"{message}\n")

    # ═══════════════════════════════════════════════════════════════════════════════
    # Node Rendering
    # ═══════════════════════════════════════════════════════════════════════════════

    @staticmethod
    def render_node(node      : Schema__Node ,                                   # Render single node
                    format    : str = "table" ,
                    for_agent : bool = False  ) -> None:
        if for_agent or format == "json":
            print(json.dumps(node.json(), indent=2))
            return

        if format == "table":
            CLI__Output.render_node_table(node)
            return

        if format == "markdown":
            CLI__Output.render_node_markdown(node)
            return

    @staticmethod
    def render_node_table(node: Schema__Node) -> None:                           # Render node as table
        print(f"{'Label':<15} {node.label}")
        print(f"{'Type':<15} {node.node_type}")
        print(f"{'Title':<15} {node.title}")
        print(f"{'Status':<15} {node.status}")

        if node.tags:
            print(f"{'Tags':<15} {', '.join(str(t) for t in node.tags)}")

        if node.description and str(node.description).strip():
            print(f"{'Description':<15} {node.description}")

        if node.links:
            print(f"\n{'Links':}")
            for link in node.links:
                print(f"  {link.verb} → {link.target_label}")

    @staticmethod
    def render_node_markdown(node: Schema__Node) -> None:                        # Render node as markdown
        print(f"# {node.label}: {node.title}\n")
        print(f"**Type:** {node.node_type}  ")
        print(f"**Status:** {node.status}  ")

        if node.tags:
            print(f"**Tags:** {', '.join(str(t) for t in node.tags)}  ")

        if node.description and str(node.description).strip():
            print(f"\n{node.description}")

        if node.links:
            print(f"\n## Links\n")
            for link in node.links:
                print(f"- **{link.verb}** → {link.target_label}")

    # ═══════════════════════════════════════════════════════════════════════════════
    # List Rendering
    # ═══════════════════════════════════════════════════════════════════════════════

    @staticmethod
    def render_list(response  : Schema__Node__List__Response ,                   # Render node list
                    format    : str  = "table"               ,
                    for_agent : bool = False                  ) -> None:
        if for_agent or format == "json":
            print(json.dumps(response.json(), indent=2))
            return

        if format == "table":
            CLI__Output.render_list_table(response)
            return

    @staticmethod
    def render_list_table(response: Schema__Node__List__Response) -> None:       # Render list as table
        if response.total == 0:
            print("No issues found.")
            return

        header = f"{'Label':<15} {'Type':<12} {'Status':<15} {'Title'}"
        print(header)
        print("─" * len(header))

        for node in response.nodes:
            print(f"{str(node.label):<15} {str(node.node_type):<12} {str(node.status):<15} {node.title}")

        print(f"\nTotal: {response.total}")

    # ═══════════════════════════════════════════════════════════════════════════════
    # Create Response Rendering
    # ═══════════════════════════════════════════════════════════════════════════════

    @staticmethod
    def render_create_response(response  : Schema__Node__Create__Response ,      # Render create result
                               format    : str  = "table"                 ,
                               for_agent : bool = False                   ) -> None:
        if for_agent or format == "json":
            print(json.dumps(response.json(), indent=2))
            return

        if response.success and response.node:
            print(f"Created {response.node.label}: {response.node.title}")

    # ═══════════════════════════════════════════════════════════════════════════════
    # Graph Rendering
    # ═══════════════════════════════════════════════════════════════════════════════

    @staticmethod
    def render_graph(response  : Schema__Graph__Response ,                       # Render graph traversal
                     format    : str  = "table"          ,
                     for_agent : bool = False            ) -> None:
        if for_agent or format == "json":
            print(json.dumps(response.json(), indent=2))
            return

        if format == "table":
            print(f"Graph from {response.root} (depth={response.depth})\n")

            print(f"{'Label':<15} {'Type':<12} {'Status':<15} {'Title'}")
            print("─" * 60)
            for node in response.nodes:
                print(f"{str(node.label):<15} {str(node.node_type):<12} {str(node.status):<15} {node.title}")

            if response.links:
                print(f"\nEdges:")
                for link in response.links:
                    print(f"  {link.source} ──{link.link_type}──▶ {link.target}")
```

---

## Error Handling

### The Error Model Already Exists

Every service method returns a response schema with `success: bool` and `message: str`. The CLI translates this to:

- `success=True` → exit code `0`, render the result
- `success=False` → exit code `1`, print `message` to stderr

```python
response = context.node_service.create_node(request)

if response.success is False:
    CLI__Output.error(response.message)
    raise typer.Exit(code=1)
```

### Error Messages from Services

The services already return descriptive error messages:

| Condition | Service Message |
|---|---|
| Node not found | `"Node not found: Task-99"` |
| Invalid node type | `"Unknown node type: widget"` |
| Empty title | `"Title is required"` |
| Link already exists | `"Link already exists"` |
| Invalid link verb | `"Unknown link type: breaks"` |
| Invalid source/target type for verb | `"bug cannot use verb has-task"` |
| Save failure | `"Failed to save node"` |
| Comment not found | `"Comment not found: a1b2c3d4"` |
| Empty comment text | `"Comment text is required"` |
| Empty author | `"Author is required"` |

The CLI does not need to add its own validation for these cases — the services handle it. The CLI only validates:

1. Label format (has a `-` separator)
2. Required positional arguments (Typer handles this)
3. `.issues/` directory discovery

### Agent-Mode Errors

When `--for-agent` is set, errors should also be JSON:

```python
if for_agent:
    print(json.dumps({"success": False, "error": response.message}))
else:
    CLI__Output.error(response.message)

raise typer.Exit(code=1)
```

---

## Main App Assembly

```python
# ═══════════════════════════════════════════════════════════════════════════════
# CLI Main - Typer app definition and command registration
# ═══════════════════════════════════════════════════════════════════════════════

import typer
from issues_fs.cli.cli__create                                                  import create
from issues_fs.cli.cli__show                                                    import show
from issues_fs.cli.cli__list                                                    import list_issues
from issues_fs.cli.cli__update                                                  import update
from issues_fs.cli.cli__delete                                                  import delete
from issues_fs.cli.cli__link                                                    import link, unlink
from issues_fs.cli.cli__comment                                                 import comment, comments
from issues_fs.cli.cli__types                                                   import types_app

app = typer.Typer(name         = "issues-fs"                                    ,
                  help         = "Git-native graph-based issue tracking"         ,
                  no_args_is_help = True                                         )

app.command("create" )(create     )
app.command("show"   )(show       )
app.command("list"   )(list_issues)
app.command("update" )(update     )
app.command("delete" )(delete     )
app.command("link"   )(link       )
app.command("unlink" )(unlink     )
app.command("comment")(comment    )
app.command("comments")(comments  )
app.add_typer(types_app, name="types")


if __name__ == "__main__":
    app()
```

---

## What to Defer — Phase Boundaries

### Phase 1: Implement Now

These commands map directly to existing services with no new dependencies:

- `create`, `update`, `show`, `list`, `delete` (Node__Service)
- `link`, `unlink` (Link__Service)
- `comment`, `comments` (Comments__Service)
- `types list`, `types init`, `link-types list` (Type__Service)
- Output formats: `table`, `json`
- `--for-agent` mode (JSON with full fields)
- `.issues/` directory discovery
- Exit codes: 0 for success, 1 for failure

### Phase 2: Implement After Service Layer Additions

These require new service-layer code but no external dependencies:

| Command | Needs | Notes |
|---|---|---|
| `issues-fs init` | New method to create `.issues/` directory structure + call `initialize_default_types()` | Straightforward |
| `issues-fs status` | Summary of current `.issues/` state | Calls `global_index_load()` + `list_node_types()` |
| `issues-fs log` | Activity/change history | Requires activity logging (not yet implemented in services) |
| `issues-fs diff` | Compare two snapshots | Requires snapshot/backup service (not yet implemented) |
| `issues-fs export` | Serialise subgraph to file | Partially possible via `get_node_graph()`, needs full-graph export |
| `issues-fs import` | Load from external source | Requires import service (not yet implemented) |
| Output: `yaml`, `markdown` | YAML requires `pyyaml` dependency | Low effort, defer for simplicity |

### Phase 3: Requires Lexicon Dependency

These features appear in the CLI architecture doc but depend on `issues-fs-lexicon`, which does not yet exist as a package:

| Feature | Lexicon Dependency |
|---|---|
| `--for-agent` output with `state_machine` field | `pattern__state_machine` from Lexicon |
| `--for-agent` output with `confidence` field | `analysis__confidence` from Lexicon |
| `--for-agent` output with `type_anchor` field | Anchor node linking from Lexicon |
| `issues-fs analyse <id> --connectivity` | `analysis__connectivity` from Lexicon |
| `issues-fs analyse <id> --pattern` | `analysis__coverage` from Lexicon |
| `issues-fs compare <id1> <id2>` | `analysis__compatibility` from Lexicon |
| `issues-fs scope` commands (fractal scopes) | Scope resolution from Lexicon |
| `issues-fs scope resolve <type>` | `analysis__scope_resolver` from Lexicon |
| State machine enforcement on `update --status` | `pattern__state_machine` from Lexicon |
| `issues-fs scratch` commands | Scratch graph concept from Lexicon/CLI design |

**Do not stub these.** Do not create placeholder commands that print "not implemented." Simply omit them from Phase 1. The CLI architecture doc covers the design; the implementation guide covers what to build now.

---

## Coding Standards — Mandatory

All code must follow the Python Formatting Guide (v3.63.4). Here is a checklist for the CLI code:

### File Structure

- Every file starts with a `═══` header comment describing the module
- Section dividers between logical groups of methods
- Blank line before imports, imports grouped by: stdlib → third-party → local

### Import Formatting

```python
# Align imports at consistent column
from typing                                                                     import Optional, List
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from issues_fs.issues.graph_services.Node__Service                              import Node__Service
from issues_fs.schemas.graph.Safe_Str__Graph_Types                              import Safe_Str__Node_Type
```

### No Docstrings

Use inline comments aligned at column 70-80:

```python
# ✗ WRONG
def show(self, label: str) -> None:
    """Display a node by label."""
    pass

# ✓ CORRECT
def show(self, label: str) -> None:                                              # Display node by label
    pass
```

### No Underscore-Prefixed Methods

```python
# ✗ WRONG
def _parse_label(self, label: str) -> tuple:

# ✓ CORRECT
def parse_label(self, label: str) -> tuple:
```

**Note:** The existing service code has `_parse_comments`, `_traverse_graph`, `_find_incoming_links` with underscore prefixes. The CLI code should not follow this pattern. These will be refactored in the services over time.

### Constructor Calls — First Parameter on Same Line

```python
# ✗ WRONG
request = Schema__Node__Create__Request(
    node_type   = node_type,
    title       = title,
)

# ✓ CORRECT
request = Schema__Node__Create__Request(node_type   = node_type ,
                                        title       = title     ,
                                        description = description)
```

### Explicit Boolean Checks

```python
# ✗ WRONG
if not response.success:

# ✓ CORRECT
if response.success is False:
```

### Aligned Assignments

```python
context    = CLI__Context()
node_type  = CLI__Label_Parser.parse_type(label)
node_label = CLI__Label_Parser.parse_label(label)
```

### Method Signatures — Vertical Alignment for Multi-Parameter

```python
def create(self                                    ,                              # Create a new node
           node_type   : Safe_Str__Node_Type       ,                              # Issue type
           title       : str                       ,                              # Issue title
           description : str                = ""                                  # Description
      ) -> Schema__Node__Create__Response:                                        # Creation result
```

### Schemas Are Pure Data — No Methods

If you need a new schema for CLI-specific output (e.g. a CLI error response), define it as a pure `Type_Safe` class with no methods:

```python
class Schema__CLI__Error(Type_Safe):                                             # CLI error response
    success : bool           = False                                             # Always False
    error   : str            = ''                                                # Error message
    command : str            = ''                                                # Command that failed
```

---

## Testing Patterns

### Test File Structure

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Test CLI Show Command
# ═══════════════════════════════════════════════════════════════════════════════

from unittest                                                                   import TestCase
from typer.testing                                                              import CliRunner
from issues_fs.cli.cli__main                                                    import app
from issues_fs.issues.graph_services.Graph__Repository__Factory                 import Graph__Repository__Factory


class Test__CLI__Show(TestCase):

    @classmethod
    def setUpClass(cls):                                                         # Create in-memory repo for tests
        cls.runner     = CliRunner()
        cls.repository = Graph__Repository__Factory.create_memory()
        # ... seed test data

    def test_show_existing_node(self):                                           # Show a node that exists
        result = self.runner.invoke(app, ["show", "Task-1"])

        assert result.exit_code == 0
        assert "Task-1"         in result.output

    def test_show_missing_node(self):                                            # Show a node that doesn't exist
        result = self.runner.invoke(app, ["show", "Task-999"])

        assert result.exit_code == 1
        assert "not found"      in result.output

    def test_show_json_output(self):                                             # Show node as JSON
        result = self.runner.invoke(app, ["show", "Task-1", "--output", "json"])

        assert result.exit_code == 0
        assert '"label"'        in result.output

    def test_show_for_agent(self):                                               # Agent-optimized output
        result = self.runner.invoke(app, ["show", "Task-1", "--for-agent"])

        assert result.exit_code == 0
        assert '"node_type"'    in result.output
```

### Test with In-Memory Backend

Tests should use `Graph__Repository__Factory.create_memory()` — never local disk. This means the CLI__Context needs to accept an injected repository for testing:

```python
class CLI__Context(Type_Safe):
    repository : Graph__Repository = None                                        # Injected or discovered

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        if self.repository is None:                                              # Only discover if not injected
            root_path       = self.discover_issues_root()
            self.repository = Graph__Repository__Factory.create_local_disk(root_path = root_path)
        # ... init services
```

---

## Performance Notes

### Graph Traversal Warning

`Node__Service._find_incoming_links()` performs a **full scan** of every node across every type to find incoming edges. This is called by `get_node_graph()` when `depth > 0`. For large repositories:

- Default `--depth` to `0` (show node only, no traversal)
- Cap `--depth` at `3` (the service already does this)
- Warn users if `--depth > 1` on repos with > 100 nodes

### Label Listing Performance

`Graph__Repository.nodes_list_labels()` scans all file paths in storage. For the local disk backend on large repos, this is I/O-bound. The global index and type indexes provide counts but not label lists — consider caching label lists if performance becomes an issue.

---

## Dependencies

### Runtime

```
osbot-utils >= 3.63.4       # Type_Safe, Safe primitives
memory-fs                   # Storage abstraction
typer >= 0.9.0              # CLI framework
```

### Dev/Test

```
pytest                      # Test runner
typer[all]                  # Includes click-testing utilities
```

### Not Required for Phase 1

```
pyyaml                      # Only if YAML output is implemented
issues-fs-lexicon           # Phase 3 (does not exist yet)
```

---

## Summary: Implementation Checklist

1. [ ] Create `issues_fs/cli/` package with `__init__.py`
2. [ ] Implement `CLI__Context` with `.issues/` discovery and service init
3. [ ] Implement `CLI__Label_Parser` with `parse_type()` and `parse_label()`
4. [ ] Implement `CLI__Output` with `table` and `json` renderers
5. [ ] Implement `cli__main.py` with Typer app and command registration
6. [ ] Implement `create` command → `Node__Service.create_node()`
7. [ ] Implement `show` command → `Node__Service.get_node()` / `get_node_graph()`
8. [ ] Implement `list` command → `Node__Service.list_nodes()`
9. [ ] Implement `update` command → `Node__Service.update_node()`
10. [ ] Implement `delete` command → `Node__Service.delete_node()`
11. [ ] Implement `link` command → `Link__Service.create_link()`
12. [ ] Implement `unlink` command → `Link__Service.delete_link()`
13. [ ] Implement `comment` command → `Comments__Service.create_comment()`
14. [ ] Implement `comments` command → `Comments__Service.list_comments()`
15. [ ] Implement `types` subcommand group → `Type__Service.*`
16. [ ] Add `[project.scripts]` entry to `pyproject.toml`
17. [ ] Write tests using `CliRunner` + in-memory backend
18. [ ] Verify all code follows formatting guide (v3.63.4)

---

*Issues-FS CLI Implementation Guide v1.0*  
*Date: 2026-02-06*
